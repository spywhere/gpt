#!/bin/bash

CLIGPT_CHECKSUM='{"lm-studio.sh":{"m":"304787e0db0d96f65eaf37c7ef698c29","s1":"107f4b0b5aaad7254e450b174384ca64ec5a3c23"},"ollama.sh":{"m":"a22c80c62bb9c66bc31edcf089afb9e0","s1":"91ef564bf84ee15d25f3dfcb33639190ad8769e1"},"openai.sh":{"m":"8cbfdf890a1c4736d7f2ae37ea3491e4","s1":"289c870a7042e9f88b5a67222f067c96395acbca"},"openrouter.sh":{"m":"cca666b60718612c9726bdcd084d686a","s1":"bcdeeb765e82f3d4fd93e09a66ed1bd9842bd34a"},"testing-platform.sh":{"m":"68948bca49a985ea807c8feaee4cf533","s1":"81040580e38413d8d3015b244a85e809ac7176e1"}}'
CLIGPT_PLATFORM_REPO="spywhere/gpt"
CLIGPT_PLATFORM_PATH="platforms"

if test -z "$HOME"; then
  HOME="$(printf '%s' ~)"
fi

if test -z "$CLIGPT_CONFIG"; then
  CLIGPT_CONFIG="$HOME/.config/gpt"
fi
if ! test -d "$CLIGPT_CONFIG"; then
  mkdir -p "$CLIGPT_CONFIG"
fi
if test -z "$CLIGPT_CACHE"; then
  CLIGPT_CACHE="$HOME/.cache/gpt"
fi

tempfile="$(mktemp)"
cmd_name="$(basename "$0")"
debug=0
fancy=0
padding=1
config_json="{}"
context=""

is_development_mode() {
  test -f README.md -a -f "./gpt" -a -d "./.git"
}

is_fancy() {
  return $(( 1 - fancy ))
}

read_configs() {
  if ! test -f "$CLIGPT_CONFIG/config.json"; then
    return
  fi

  config_json="$(jq -c . "$CLIGPT_CONFIG/config.json")"
  if test $? -ne 0; then
    echo "ERROR: configurations cannot be read" >&2
    exit 1
  fi
}

get_config() {
  if test -n "$1"; then
    parsejson "$config_json" --arg platform "$1" --arg key "$2" --arg default "$(get_config '' "$2" "$3")" '.platforms[$platform][$key] // $default'
    return $?
  fi

  parsejson "$config_json" --arg key "$2" --arg default "$3" '.[$key] // $default'
}

load_configs() {
  CLIGPT_PLATFORM="$(get_config '' platform)"
  CLIGPT_TEMP="$(get_config "$CLIGPT_PLATFORM" temperature)"
  CLIGPT_TOKEN="$(get_config "$CLIGPT_PLATFORM" token)"
  CLIGPT_TIMEOUT="$(get_config "$CLIGPT_PLATFORM" timeout)"

  CLIGPT_MODEL="$(get_config "$CLIGPT_PLATFORM" model)"
  CLIGPT_API_BASE="$(get_config "$CLIGPT_PLATFORM" base_url)"
  CLIGPT_API_AUTHORIZATION="$(get_config "$CLIGPT_PLATFORM" authorization)"
}

write_configs() {
  if ! test -d "$CLIGPT_CONFIG"; then
    mkdir -p "$CLIGPT_CONFIG"
  fi

  printf '%s' "$config_json" | jq . > "$CLIGPT_CONFIG/config.json"
}

migrate_configs() {
  if test "$(parsejson "$config_json" '.')" != "{}"; then
    return
  fi

  set_config() {
    if test -z "$3"; then
      echo "$1"
      return
    fi

    if test "$4" = '--raw'; then
      setitem "$1" "$2" "$3"
    else
      setitem "$1" "$2" "$(tojson "$3")"
    fi
  }

  config_json="$(set_config "$config_json" platform "$CLIGPT_PLATFORM")"
  config_json="$(set_config "$config_json" temperature "$CLIGPT_TEMP" --raw)"
  config_json="$(set_config "$config_json" token "$CLIGPT_TOKEN" --raw)"
  config_json="$(set_config "$config_json" timeout "$CLIGPT_TIMEOUT" --raw)"

  local platforms
  platforms="$(get_config '' platforms '{}')"

  if test -n "$CLIGPT_PLATFORM"; then
    local platform
    platform="$(parsejson "$platforms" --arg platform "$CLIGPT_PLATFORM" '.[$platform] // {}')"

    platform="$(set_config "$platform" model "$CLIGPT_MODEL")"
    platform="$(set_config "$platform" base_url "$CLIGPT_API_BASE")"
    platform="$(set_config "$platform" authorization "$CLIGPT_API_AUTHORIZATION")"

    platforms="$(setitem "$platforms" "$CLIGPT_PLATFORM" "$platform")"
  fi

  config_json="$(setitem "$config_json" platforms "$platforms")"
  write_configs
  echo "${esc_blue}INFO:$esc_reset Environment variables have been migrated into $esc_yellow$CLIGPT_CONFIG/config.json$esc_reset" >&2
}

esc_reset="" # reset
esc_gray="" # indicate hints
esc_blue="" # indicate system messages
esc_green="" # indicate user messages
esc_yellow="" # indicate assistant messages
esc_red="" # indicate errors

inline_support=0
if test -n "$CLIGPT_FORCE_COLOR" || (test -t 1 && test -n "$TERM" -a -n "$(command -v tput)" && test "$(tput colors)" -ge 8 && test -n "$(command -v tty)"); then
  if test -n "$(command -v wc)"; then
    inline_support=1
  fi
  esc_reset="$(tput sgr0)"
  esc_gray="$(tput setaf 8)"
  if test "$(tput colors)" -gt 8; then
    esc_blue="$(tput setaf 12)"
    esc_green="$(tput setaf 10)"
    esc_yellow="$(tput setaf 11)"
    esc_red="$(tput setaf 9)"
  else
    esc_blue="$(tput setaf 4)"
    esc_green="$(tput setaf 2)"
    esc_yellow="$(tput setaf 3)"
    esc_red="$(tput setaf 1)"
  fi

  draw_ui() {
    if ! is_fancy || test -z "$context"; then
      return
    fi
    tput sc
    # Add a new line
    tput il 1
    # Change scroll region to exclude the last lines
    tput csr 0 $(($(tput lines) - padding - 3))

    tput cup "$(( $(tput lines) - 2 - padding ))" 0
    printf '%s\n' "$(repeat -)"
  }

  restore_ui() {
    if ! is_fancy || test -z "$context"; then
      return
    fi
    tput rc
    tput ed
    tput rc >&2
    tput ed >&2
  }

  display_image() {
    local width="$(( $(tput cols) / 4 ))"
    local height="$(( $(tput lines) / 8 ))"
    if test -n "$(command -v timg)"; then
      timg "-g${width}x${height}" -I "$1" 2>/dev/null
    fi

    printf '%s\n' "$2" >&2
  }
  display_image_url() {
    curl -sLo- "$1" | display_image - "$2"
  }
else
  draw_ui() {
    return 0
  }
  restore_ui() {
    return 0
  }
  display_image() {
    printf '%s\n' "$2" >&2
  }
  display_image_url() {
    display_image "$1" "$2"
  }
fi

is_interactive() {
  return $(( 1 - inline_support ))
}

bootstrap() {
  if test -z "$CLIGPT_PLATFORM_STORAGE"; then
    if is_development_mode; then
      CLIGPT_PLATFORM_STORAGE="./$CLIGPT_PLATFORM_PATH"
    else
      CLIGPT_PLATFORM_STORAGE="$CLIGPT_CACHE/$CLIGPT_PLATFORM_PATH"
    fi
  fi

  if test -z "$CLIGPT_CONTEXT_STORAGE"; then
    CLIGPT_CONTEXT_STORAGE="."
  fi
  if test -z "$CLIGPT_TIMEOUT"; then
    CLIGPT_TIMEOUT=30
  fi

  load_platforms
  read_configs
  migrate_configs
  load_configs
}

fallback_default() {
  if test -n "$1" -a "$1" != "$3"; then
    printf '%s' "$1"
  elif test -n "$2"; then
    printf '%s' "$2"
  else
    printf 'platform specific value'
  fi
}

usage() {
  echo "USAGE"
  echo "  $cmd_name [flags] [--] <prompt>..."
  echo "  cat <filename> | $cmd_name [flags] [--] [prompt]..."
  echo
  echo "PLATFORMS"
  if test "$platforms" = "{}"; then
    echo "  A list of platforms will be downloaded upon first run. Or simply run '$cmd_name --platforms' to start download now"
  else
    first_line='      \(.value.description)\n'
    second_line='        Default API base URL : \(.value.base // "None specified")'
    parsejson "$platforms" -S "to_entries | map(\"  - \(.key)\n$first_line$second_line\") | join(\"\n\")"
    echo
    echo "  By default, each platform will be tested for a valid setup and get selected. Any platform required a remote call will not be tested and will be selected as a fallback."
  fi

  echo
  echo "ENVIRONMENT VARIABLES"
  echo "  CLIGPT_CONFIG              Directory to store/load the configurations (currently set to $CLIGPT_CONFIG)"
  echo "  CLIGPT_CACHE               Directory to store/load the cache, such as supported platforms (currently set to $CLIGPT_CACHE)"
  echo "  CLIGPT_CONTEXT_STORAGE     Directory to store/load the context file (currently set to $(fallback_default "$CLIGPT_CONTEXT_STORAGE" "current directory" "."))"
  echo "  CLIGPT_PLATFORM_STORAGE    Directory to store/load the supported platforms (currently set to $CLIGPT_PLATFORM_STORAGE)"
  echo
  echo "  CLIGPT_FORCE_COLOR         Set to non-empty to force rendering with colors"
  echo "  CLIGPT_NO_HINT             Set to non-empty to disable hintings"
  echo
  echo "FLAGS"
  echo "  -h, --help                 Show this message"
  echo "  -p, --platform=<name>      LLM platform to use (see PLATFORMS above for more details)"
  echo "  -m, --model=<name>         ID of the model to use (default to $(fallback_default "$CLIGPT_MODEL"))"
  echo "  -f, --file=<file/url>      File to be attached along with a prompt"
  echo "  -T, --temperature=<temp>   Sampling temperature, higher is more random (default to $(fallback_default "$CLIGPT_TEMP"))"
  echo "  -t, --max-tokens=<number>  Maximum number of tokens to generate in the completion (default to $(fallback_default "$CLIGPT_TOKEN"))"
  echo "  -c, --context[=<file>]     Use chat context (default to false), optionally use and store the context in the given file. The prompt from command line will be passed as a system message to the assistant, cannot be used in a pipe"
  echo "  --timeout=<number>         Maximum number of seconds before request timed out (default to "$(fallback_default "$CLIGPT_TIMEOUT")")"
  echo "  --fancy[=<number>]         Use fancy UI with the given minimum padding (default to "$padding")"
  echo "  --platforms                List all available platforms (will start download supported platforms if no platform found)"
  echo "  --models                   List all available models"
  echo "  --uuid                     A unique ID for verifying the tool"
  echo "  --debug                    Print request and response on to standard error"
  echo "  --debug-dry                Print request to standard error, but do not make a request"
  echo
  echo "PROMPT HELPER -- cannot used with context"
  echo "  --cmd, --command           Produce only shell command output"
  echo "  --cmds, --commands         Produce 3 shell commands output (alternatives)"
  echo "  --code                     Produce only one-liner code"
  echo "  --url                      Produce only URL for the given query"
  echo
  echo "CONTEXT LOADER"
  echo "  --fzf                      Fuzzy search for the context file in context storage (see CLIGPT_CONTEXT_STORAGE above) using fzf (fzf is required)"

  if test "$cmd_name" != "prepare-commit-msg"; then
    echo
    echo "ADDITIONAL USAGE"
    echo "  Symlink (or copy) this script as your 'prepare-commit-msg' hook on your git repository to have GPT suggested a commit message"
    echo "    ln -fs $0 /path/to/repo/.git/hooks/prepare-commit-msg"
    echo
    echo "  Add the following line to your .zshrc to enable GPT command lookup using '# <query>'"
    echo "    . <($cmd_name --zsh)"
  fi
}

prompt_prefix() {
  local prompt
  case "$1" in
    copilot)
      prompt='a structured and complete explanations of shell commands. We follow the commands piece-by-piece in bullet-point form, with multiple statements being separate bullets. Sub-commands form sub-bullets. All flags are explained as sub-bullets.'
      ;;
    command)
      prompt='a single, widely accepted one-liner POSIX shell command for the given request. The command must be written in plain text, ready to run directly in the terminal. Do not include explanations, escape characters, syntax highlighting, code blocks, or any formatting. Only output the command as plain text.'
      ;;
    commands)
      prompt='exactly three one-liner POSIX shell commands for the given request. Each command must be on a separate line, written in plain text, and ready to run directly in the terminal. Do not include explanations, escape characters, syntax highlighting, or any formatting (e.g., code blocks or markdown). Only output the commands as plain text.'
      prompt="$(printf '%s\n\n== EXAMPLES ==\nQ: list a file in a current directory\nA:\nls\nfind . -depth 1\necho *\n\nQ: print exact location of a command\nA:\ncommand -v <command>\nwhich <command>\ntype -a <command>\n\nQ: find a text "test" in a file\nA:\ngrep test <file>\nawk "/test/" <file>\nsed -n -e "/test/p" <file>' "$prompt")"
      ;;
    code)
      prompt='a single, concise, and widely accepted one-liner code snippet for the given request. The code must be written in plain text, ready to use directly, and optimized for brevity and simplicity. Do not include explanations, escape characters, syntax highlighting, code blocks, or any formatting. Only output the code as plain text.'
      ;;
    url)
      prompt='an URL regarding on the topic given. Only produce the URL in plain text with no escape or syntax settings and nothing else, the URL will be open in the browser directly.'
      ;;
  esac

  printf 'Given the user request, only produce %s' "$prompt"
}

copilot_examples() {
  local prompts="$*"
  local result

  local command='find -name "*.ts" | grep -v node_modules'
  local additional
  additional="$("$CLIGPT_PLATFORM" messages user "$command")"
  if test $? -ne 0; then
    return 1
  fi
  prompts="$(additems "$prompts" "$additional")"
  # shellcheck disable=SC2016
  result="$(printf -- '--- Command ---\n\n%s\n\n--- Explanation ---\n\n- %s\n  - %s\n- %s\n  - %s' "$command" '`find` is used to list files.' '`-name "*.ts"` stipulates that we search for files ending in `.ts`.' '`| grep` means we pass that list of files to `grep` which filters the list.' '`-v node_modules` means we exclude all files containing node_modules in its path.')"
  additional="$("$CLIGPT_PLATFORM" messages assistant "$result")"
  if test $? -ne 0; then
    return 1
  fi
  prompts="$(additems "$prompts" "$additional")"

  # shellcheck disable=SC2016
  command="$(printf '%s\n  %s\n  %s\n%s' 'for file in $(find -name "*.py"); do' 'echo "$file";' 'wc -l $file;' 'done')"
  additional="$("$CLIGPT_PLATFORM" messages user "$command")"
  if test $? -ne 0; then
    return 1
  fi
  prompts="$(additems "$prompts" "$additional")"
  # shellcheck disable=SC2016
  result="$(printf -- '--- Command ---\n\n%s\n\n--- Explanation ---\n\n- %s\n  - %s\n    - %s\n- %s\n  - %s\n  - %s\n    - %s' "$command" 'The for loop iterates over a list of items and executes its body for each, using the loop variable `$file`.' 'The list of items is the output of a sub-call to `find` which is used to list files.' '`-name "*.py"` stipulates that we search for files ending in `.py`.' 'The loop body executes two commands for each file:' '`echo "$file"` will print the name of the current file to the terminal.' '`wc` is used to count the number of lines in the current file.' '`-l` specifies that we only want the line count, not the word or character count.')"
  additional="$("$CLIGPT_PLATFORM" messages assistant "$result")"
  if test $? -ne 0; then
    return 1
  fi
  prompts="$(additems "$prompts" "$additional")"

  printf '%s' "$prompts"
}

additional_prompts() {
  case "$1" in
    copilot)
      copilot_examples "$2"
      ;;
    *)
      printf '%s' "$2"
  esac
}

loader() {
  local pid=$1
  local anim=".  .. ... ..  .   "
  local delay=0.3
  while true; do
    if ! kill -0 "$pid" 2>/dev/null; then
      printf '\r   \r' >&2
      break
    fi

    local char="$(echo "$anim" | cut -c1-3)"
    printf '\r%s' "$char" >&2
    anim="$(echo "$anim" | cut -c4-)$char"
    sleep "$delay"
  done

  wait "$pid"
  return $?
}

run_task() {
  local task="$1"
  if ! is_interactive; then
    "$task"
    return $?
  fi

  "$task" >"$tempfile" &
  loader "$!"
  local code="$?"
  cat "$tempfile"
  return "$code"
}

validate_checksum() {
  if test "$1" = "s1" && test -z "$(command -v shasum)"; then
    return 1
  fi
  if test "$1" = "m" && test -z "$(command -v md5sum)"; then
    return 1
  fi

  local checksum
  if test "$1" = "s1"; then
    checksum="$(shasum -a1 "$3" | cut -d' ' -f1)"
  elif test "$1" = "m"; then
    checksum="$(md5sum "$3" | cut -d' ' -f1)"
  fi
  test "$checksum" = "$(parsejson "$CLIGPT_CHECKSUM" --arg name "$2" --arg alg "$1" '.[$name][$alg]')"
}

load_platforms() {
  platforms="{}"
  for platform_path in "$CLIGPT_PLATFORM_STORAGE"/*.sh; do
    local platform_name="$(basename "$platform_path")"
    if test "$platform_name" = '*.sh'; then
      break
    fi

    if ! is_development_mode && ! validate_checksum s1 "$platform_name" "$platform_path" && ! validate_checksum m "$platform_name" "$platform_path"; then
      echo "WARN: platform '$platform_name' integrity is invalid, updating platforms." >&2
      platforms="{}"
      return
    fi

    . "$platform_path"
    local platform_data="$(platform_info)"
    platforms="$(setitem "$platforms" "$(parsejson "$platform_data" '.fn')" "$platform_data")"
  done
}

download_platforms() {
  if test "$platforms" != "{}"; then
    return
  fi

  echo "Fetching platforms..." >&2
  platform_files="$(curl -sSL -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" "https://api.github.com/repos/$CLIGPT_PLATFORM_REPO/contents/$CLIGPT_PLATFORM_PATH" | jq 'map({ (.name|tostring): . }) | add')"
  if test "$?" -ne 0; then
    echo "ERROR: failed to fetch a list of platforms" >&2
    return 1
  fi
  for platform_file in $(parsejson "$platform_files" 'keys[]'); do
    local platform_data="$(parsejson "$platform_files" ".[\"$platform_file\"]")"
    local platform_url="$(parsejson "$platform_data" '.download_url')"

    if ! test -d "$CLIGPT_PLATFORM_STORAGE"; then
      printf "Creating a directory '%s'... " "$CLIGPT_PLATFORM_STORAGE" >&2
      mkdir -p "$CLIGPT_PLATFORM_STORAGE"
      printf 'done\n'
    fi

    printf "Downloading platform '%s' into '%s'... " "$platform_file" "$CLIGPT_PLATFORM_STORAGE/$platform_file" >&2
    curl -sSL "$platform_url" -o "$CLIGPT_PLATFORM_STORAGE/$platform_file" >/dev/null 2>&1
    if test "$?" -ne 0; then
      printf 'failed\n' >&2
      echo "ERROR: failed to download platform '$platform_file'" >&2
      return 1
    fi
    printf "done\nChecking platform '%s' integrity... " "$platform_file" >&2
    if ! validate_checksum s1 "$platform_file" "$CLIGPT_PLATFORM_STORAGE/$platform_file" && ! validate_checksum m "$platform_file" "$CLIGPT_PLATFORM_STORAGE/$platform_file"; then
      printf 'failed\n' >&2
      echo "ERROR: failed to verify platform '$platform_file', try updating the tool ($cmd_name) itself" >&2
      return 1
    fi
    printf 'ok\n' >&2
  done

  load_platforms

  if test "$platforms" = "{}"; then
    echo "ERROR: no available platform found" >&2
    return 1
  fi
}

validate_platform() {
  if ! download_platforms; then
    return 2
  fi

  if test -z "$(command -v shasum)" -a -z "$(command -v md5sum)"; then
    echo "WARN: 'shasum' or 'md5sum' is missing, skip platform integrity check" >&2
  fi

  local has_test=0
  if test -z "$CLIGPT_PLATFORM"; then
    for platform_name in $(parsejson "$platforms" 'keys[]'); do
      if "$platform_name" test; then
        CLIGPT_PLATFORM="$platform_name"
        has_test=1
        echo "No platform specified, using '$CLIGPT_PLATFORM' instead" >&2
        break
      fi
    done
  fi

  if test -z "$CLIGPT_PLATFORM"; then
    echo "ERROR: no valid platform found" >&2
    return 1
  fi

  local platform_data="$(parsejson "$platforms" ".[\"$CLIGPT_PLATFORM\"].fn // \"\"")"
  if test $? -ne 0 -o -z "$platform_data"; then
    echo "ERROR: platform '$CLIGPT_PLATFORM' is not a valid platform" >&2
    return 1
  fi

  if test "$has_test" -eq 0 && ! "$CLIGPT_PLATFORM" test; then
    echo "ERROR: platform '$CLIGPT_PLATFORM' is not a valid platform (failed the test)" >&2
    return 3
  fi
}

handle_status() {
  local status="$1"
  case "$status" in
    0)
      ;;
    1)
      restore_ui
      echo "ERROR: Request timed out" >&2
      ;;
    2)
      restore_ui
      echo "ERROR: Bad response" >&2
      ;;
    3|4)
      ;;
    *)
      restore_ui
      echo "ERROR: Request failed" >&2
      ;;
  esac
  return "$status"
}

handle_json_response() {
  local response="$1"
  local error_message="$2"
  local error_type="$3"
  local errmsg
  errmsg="$(printf '%s' "$response" | jq -er "$error_message")"
  if test "$?" -eq 0; then
    restore_ui
    if test -z "$error_type" -o "$error_type" = '-'; then
      printf 'ERROR: %s\n' "$errmsg" >&2
    else
      printf 'ERROR: [%s] %s\n' "$(parsejson "$response" "$error_type")" "$errmsg" >&2
    fi
    return 1
  fi
  return 0
}

http_json() {
  local base="$1"
  local error_message="$2"
  local error_type="$3"
  shift
  shift
  shift

  local path="$1"
  local body="$2"
  local filter="$3"
  local method="POST"
  if test -z "$3"; then
    body=""
    filter="$2"
    method="GET"
  elif test "$debug" -ge 1; then
    printf 'Req[%s]: %s\n' "$path" "$body" >&2
  fi
  if test "$debug" -eq 2; then
    return 4
  fi
  task() {
    send_req() {
      curl -m "$CLIGPT_TIMEOUT" -X "$method" -d "$body" -sSL "$base/$path" -H 'Content-Type: application/json' "$@" 2>/dev/null
    }
    if test -z "$CLIGPT_API_AUTHORIZATION"; then
      send_req
    else
      send_req -H "Authorization: $CLIGPT_API_AUTHORIZATION"
    fi
  }
  local response
  response="$(run_task task)"
  if test $? -ne 0; then
    return 1
  fi

  if test "$debug" -ge 1; then
    printf 'Res[%s]: %s\n' "$path" "$response" >&2
  fi

  parsejson "$response" '.' >/dev/null 2>&1
  if test $? -ne 0; then
    return 2
  fi

  if ! handle_json_response "$response" "$error_message" "$error_type"; then
    return 3
  fi

  parsejson "$response" "$filter"
}

parsejson() {
  local value="$1"
  shift
  printf '%s' "$value" | jq -rc "$@"
}

tojson() {
  printf '%s' "$*" | jq -sRr 'tojson'
}

setitem() {
  printf '{"o":%s,"k":%s,"v":%s}' "$1" "$(tojson "$2")" "$3" | jq -rc '.o[.k] = .v | .o'
}

additems() {
  printf '{"o":%s,"i":%s}' "$1" "$2" | jq -rc '.o + .i'
}

additem() {
  additems "$1" "[$2]"
}

list_platforms() {
  if ! download_platforms; then
    return 1
  fi

  echo "Available platforms:"
  parsejson "$platforms" 'keys[] | "  - \(.)"'
}

models() {
  echo "Available models:"
  local models="$("$CLIGPT_PLATFORM" models)"
  if ! handle_status "$?"; then
    exit 1
  fi
  parsejson "$models" '.[]'
}

validate_context() {
  local context="$1"
  if ! test -f "$context"; then
    echo "ERROR: a given context '$context' is not found" >&2
    return 1
  fi

  local prompts="$(jq -c . "$context" 2>/dev/null)"
  if test $? -ne 0; then
    echo "ERROR: a given context '$context' is not in a correct structure" >&2
    return 1
  fi

  if test -n "$2"; then
    printf '%s' "$prompts"
  fi
}

parse_context() {
  local context="$1"
  if ! validate_context "$context"; then
    return 1
  fi
  local filter=' | "\({"system": "\($blue)[System]\($reset)", "user": "\($green)[User]\($reset)", "assistant": "\($yellow)[Assistant]\($reset)"}[.role] // "[\(.role  / "" | .[:1] |= map(ascii_upcase) | add)]") \(.content)"'
  jq -r ".[]$filter" --arg reset "$esc_reset" --arg blue "$esc_blue" --arg green "$esc_green" --arg yellow "$esc_yellow" "$context"
}

repeat() {
  local str="$1"
  if test -z "$str"; then
    str=" "
  fi
  for i in $(seq "$(tput cols)"); do
    printf '%s' "$str"
  done
}

multiline() {
  local first_line="$(printf '%s' "$1" | sed "s/^$2//g")"
  local lines="$first_line"

  while true; do
    printf '   %s...%s ' "$esc_green" "$esc_reset" >&2
    if read -r line; then
      if test -z "$line"; then
        continue
      fi

      case "$line" in
        *"$2")
          local last_line="$(printf '%s' "$line" | sed "s/^$2//g")"
          lines="$(printf '%s\n%s' "$lines" "$last_line")"
          break
          ;;
        *)
          lines="$(printf '%s\n%s' "$lines" "$line")"
      esac
    else
      printf '\n' >&2
      break
    fi
  done

  printf '%s' "$lines"
}

command_help() {
  echo 'Available commands:'
  echo '  `, """                             Prefix the prompt with a backtick or triple quotes for multi-line prompt'
  echo '  /help, /h, /?                      Print this help message'
  echo '  /clear, /forget                    Clear the conversation'
  echo '  /upload [file], /attach [file]     Clear all attachments or add an attachment along with the next prompt'
  echo '  /system <prompt>                   Insert system prompt into the conversation'
  echo '  /regenerate, /regen                Regenerate the last response'
  echo '  /undo                              Remove the last prompt and response'
  echo '  /dump [context]                    Print the raw conversation or save into a given context file'
  echo '  /temperature [temp], /temp [temp]  Set a new temperature value or reset to default'
  echo '  /token [token]                     Set a new token size or reset to default'
  echo '  /timeout <timeout>                 Set a new timeout value'
  echo '  /info                              Print the currently running platform, model'
  echo '  /exit, /quit, /bye                 End the conversation'
}

_remove_from() {
  parsejson "$2" "del(.[range(index(map(select($3))|$1);index(last)+1)])"
}

remove_from_first() {
  _remove_from first "$@"
}

remove_from_last() {
  _remove_from last "$@"
}

confirm() {
  printf '%s [y/N] ' "$1"
  while true; do
    if read -r line; then
      case "$line" in
        y|Y)
          return 0
          ;;
        *)
          return 1
          ;;
      esac
    else
      printf '\n'
      return 2
    fi
  done
}

main() {
  local use_stdin=1
  if tty -s >/dev/null 2>&1; then
    use_stdin=0
  fi
  bootstrap
  local kind=""
  local task=""
  while test "$1" != ""; do
    local param="$(printf '%s' "$1" | sed 's/=.*//g')"
    local value="$(printf '%s' "$1" | sed 's/^[^=]*=//g')"
    local equal_sign="$(printf '%s' "$1" | sed 's/[^=]//g')"
    case "$param" in
      -h | --help)
        usage
        return
        ;;
      --zsh)
        setup_zsh
        return
        ;;
      --platforms)
        list_platforms
        return
        ;;
      --models)
        task="models"
        ;;
      --uuid)
        echo "4210bbbd-7376-4c55-ac3a-093552be821c"
        return
        ;;
      --fzf)
        if ! test -n "$(command -v fzf)"; then
          echo "ERROR: fzf is required" >&2
          return 1
        fi
        if test -z "$CLIGPT_CONTEXT_STORAGE"; then
          echo "ERROR: GPT_CONTEXT_STORAGE is not yet setup" >&2
          return 1
        elif ! test -d "$CLIGPT_CONTEXT_STORAGE"; then
          echo "ERROR: no context found on \"$CLIGPT_CONTEXT_STORAGE\" (perhaps storage is empty?)" >&2
          return 1
        fi
        shift
        output="$(find "$CLIGPT_CONTEXT_STORAGE" -maxdepth 1 -type f | rev | cut -d'/' -f1 | rev | fzf "--preview=CLIGPT_FORCE_COLOR=1 $0 --parse={}" '--bind=ctrl-/:toggle-preview,ctrl-d:preview-half-page-down,ctrl-u:preview-half-page-up' '--preview-label=Chat History' '--preview-window=down:70%:wrap')"
        if test -z "$output"; then
          return 1
        fi
        context="$(realpath "$CLIGPT_CONTEXT_STORAGE/$output")"
        ;;
      --timeout)
        if test -z "$equal_sign"; then
          echo "ERROR: a number of seconds is required (perhaps missing an equal sign?)" >&2
          return 1
        fi
        CLIGPT_TIMEOUT="$value"
        ;;
      -f | --file)
        if test -z "$equal_sign"; then
          echo "ERROR: a file/URL is required (perhaps missing an equal sign?)" >&2
          return 1
        fi

        case "$value" in
          http://*|https://*)
            CLIGPT_FILE="$value"
            ;;
          *://*)
            echo "ERROR: URL '$value' is not allowed" >&2
            return 1
            ;;
          *)
            if test -f "$value"; then
              CLIGPT_FILE="$value"
            else
              echo "ERROR: file '$value' is not exists" >&2
              return 1
            fi
            ;;
        esac
        ;;
      -T | --temperature)
        if test -z "$equal_sign"; then
          echo "ERROR: a temperature is required (perhaps missing an equal sign?)" >&2
          return 1
        fi
        CLIGPT_TEMP="$value"
        ;;
      -t | --max-tokens)
        if test -z "$equal_sign"; then
          echo "ERROR: a number of tokens is required (perhaps missing an equal sign?)" >&2
          return 1
        fi
        CLIGPT_TOKEN="$value"
        ;;
      -p | --platform)
        if test -z "$equal_sign"; then
          echo "ERROR: a platform is required (perhaps missing an equal sign?)" >&2
          return 1
        fi
        CLIGPT_PLATFORM="$value"
        ;;
      -m | --model)
        if test -z "$equal_sign"; then
          echo "ERROR: a model ID is required (perhaps missing an equal sign?)" >&2
          return 1
        fi
        CLIGPT_MODEL="$value"
        ;;
      -c | --context)
        if test -z "$equal_sign"; then
          context='-'
        elif test -f "$CLIGPT_CONTEXT_STORAGE/$value"; then
          context="$(realpath "$CLIGPT_CONTEXT_STORAGE/$value")"
        else
          context="$(realpath "$CLIGPT_CONTEXT_STORAGE")/$value"
        fi
        ;;
      --parse)
        if test -z "$equal_sign"; then
          echo "ERROR: a context is required (perhaps missing an equal sign?)" >&2
          return 1
        else
          parse_context "$value" 2>/dev/null
          if test $? -ne 0; then
            echo "ERROR: a given context '$value' is not in a correct structure" >&2
            return 1
          fi
          return
        fi
        ;;
      --copilot)
        kind="copilot"
        ;;
      --cmd | --command)
        kind="command"
        ;;
      --cmds | --commands)
        kind="commands"
        ;;
      --code)
        kind="code"
        ;;
      --url)
        kind="url"
        ;;
      --fancy)
        fancy=1
        if test -n "$equal_sign"; then
          padding="$value"
        fi
        ;;
      --debug)
        debug=1
        ;;
      --debug-dry)
        debug=2
        ;;
      --)
        shift
        break
        ;;
      -*)
        echo "ERROR: unknown flag \"$1\"" >&2
        return 1
        ;;
      *)
        break
        ;;
    esac

    shift
  done

  if ! validate_platform; then
    return 1
  fi

  if test -n "$task"; then
    "$task"
    return
  fi

  local prompt=""
  if test "$use_stdin" -eq 1; then
    if ! is_development_mode && test -n "$context"; then
      echo "ERROR: context cannot be used in the pipe" >&2
      return 1
    elif test -z "$context"; then
      if test -n "$*"; then
        prompt="$(printf '%s:\n%s' "$*" "$(cat -)")"
      else
        prompt="$(cat -)"
      fi
    fi
  else
    prompt="$*"
  fi
  if test -z "$context" && test -z "$prompt"; then
    echo "No prompt given" >&2
    if test -z "$CLIGPT_NO_HINT"; then
      echo "Use --help for usage" >&2
    fi
    return
  fi

  if test -z "$CLIGPT_NO_HINT"; then
    printf '%splatform: %s%s\n' "$esc_gray" "$CLIGPT_PLATFORM" "$esc_reset" >&2
    printf '%smodel   : %s%s\n' "$esc_gray" "$CLIGPT_MODEL" "$esc_reset" >&2
  fi

  local prompts="[]"
  if test -n "$context"; then
    if test "$context" != '-'; then
      printf '%scontext : %s%s\n' "$esc_gray" "$context" "$esc_reset" >&2
    fi
    if test "$context" != '-' && test -f "$context"; then
      prompts="$(validate_context "$context" yes)"
      if test $? -ne 0; then
        return 1
      fi
      parse_context "$context" 2>/dev/null
      if test $? -ne 0; then
        echo "ERROR: a given context '$context' is not in a correct structure" >&2
        return 1
      fi
    elif test -n "$prompt"; then
      local data
      data="$("$CLIGPT_PLATFORM" messages system "$prompt")"
      if test $? -ne 0; then
        return 1
      fi
      prompts="$(additems "$prompts" "$data")"
      printf '%s[System]%s %s\n' "$esc_blue" "$esc_reset" "$prompt"
    fi
  fi

  while true; do
    local skip=0
    local current_items=""
    if test -n "$context"; then
      draw_ui
      printf '%s[User]%s ' "$esc_green" "$esc_reset"
      if read -r line; then
        if is_development_mode && test -n "$context"; then
          printf '%s\n' "$line"
        fi
        restore_ui
        if test -z "$line"; then
          break
        fi
        if is_fancy; then
          printf '%s[User]%s %s\n' "$esc_green" "$esc_reset" "$line"
        fi

        case "$line" in
          /*)
            local command="$(printf '%s' "$line" | sed 's/ .*//g')"
            local value="$(printf '%s' "$line" | sed 's/^[^ ]* //g')"
            local space_symbol="$(printf '%s' "$line" | sed 's/[^ ]//g')"
            if test -z "$space_symbol"; then
              value=""
            fi

            case "$command" in
              /dump)
                if test -z "$value"; then
                  echo "$prompts" >&2
                else
                  if test -f "$CLIGPT_CONTEXT_STORAGE/$value"; then
                    if confirm "Context '$value' already exists, overwrite?"; then
                      context="$(realpath "$CLIGPT_CONTEXT_STORAGE/$value")"
                    else
                      continue
                    fi
                  else
                    context="$(realpath "$CLIGPT_CONTEXT_STORAGE")/$value"
                  fi

                  echo "Context will be stored in '$context'" >&2
                  printf '%s' "$prompts" > "$context"
                fi
                ;;
              /upload|/attach)
                case "$value" in
                  \~/*)
                    value="$(printf '%s' "$HOME")/$(printf '%s' "$value" | sed 's/^~\///g')"
                    ;;
                  *)
                    ;;
                esac

                case "$value" in
                  http://*|https://*)
                    display_image_url "$value" "URL '$value' will be attached with the next prompt"
                    CLIGPT_FILE="$value"
                    ;;
                  *://*)
                    echo "ERROR: URL '$value' is not allowed" >&2
                    ;;
                  *)
                    if test -z "$(command -v base64)"; then
                      echo "WARN: base64 is missing, skipping attachment" >&2
                    elif test -z "$value"; then
                      echo "All attachment cleared" >&2
                      CLIGPT_FILE=""
                    elif test -f "$value"; then
                      display_image "$value" "File '$value' will be attached with the next prompt"
                      CLIGPT_FILE="$value"
                    else
                      echo "ERROR: file '$value' is not exists" >&2
                    fi
                    ;;
                esac
                ;;
              /system)
                # TODO: Add system prompt
                ;;
              /undo)
                prompts="$(remove_from_last "$prompts" '.role=="user"')"
                ;;
              /regenerate|/regen)
                prompts="$(remove_from_last "$prompts" '.role=="assistant"')"
                skip=1
                ;;
              /clear|/forget)
                prompts="$(remove_from_first "$prompts" '.role=="user"')"
                ;;
              /timeout)
                if test -z "$value"; then
                  echo "ERROR: a timeout value is required" >&2
                else
                  CLIGPT_TIMEOUT="$value"
                fi
                ;;
              /temperature|/temp)
                if test -z "$value"; then
                  CLIGPT_TEMP=""
                  echo "Temperature value has been reset to the default value" >&2
                else
                  CLIGPT_TEMP="$value"
                fi
                ;;
              /token)
                if test -z "$value"; then
                  CLIGPT_TOKEN=""
                  echo "Token size has been reset to the default value" >&2
                else
                  CLIGPT_TOKEN="$value"
                fi
                ;;
              /info)
                echo "Platform: $CLIGPT_PLATFORM" >&2
                echo "Model: $CLIGPT_MODEL" >&2
                echo "Timeout: ${CLIGPT_TIMEOUT}s" >&2
                if test -n "$CLIGPT_TEMP"; then
                  echo "Temperature: $CLIGPT_TEMP" >&2
                fi
                if test -n "$CLIGPT_TOKEN"; then
                  echo "Max tokens: $CLIGPT_TOKEN" >&2
                fi
                ;;
              /help|/h|/\?)
                command_help >&2
                ;;
              /exit|/quit|/bye)
                break
                ;;
              *)
                echo "ERROR: a command '$command' is not a valid command. Try /help to see available commands" >&2
                ;;
            esac

            if test "$skip" -eq 0; then
              continue
            fi
            ;;
          '`'*)
            line="$(multiline "$line" '`')"
            ;;
          '"""'*)
            line="$(multiline "$line" '"""')"
            ;;
          *)
            ;;
        esac

        current_items="$("$CLIGPT_PLATFORM" messages user "$line")"
        if test $? -ne 0; then
          continue
        fi
      else
        printf '\n'
        restore_ui
        break
      fi
    else
      if test -n "$kind"; then
        local prefix
        prefix="$("$CLIGPT_PLATFORM" messages system "$(prompt_prefix "$kind")")"
        if test $? -ne 0; then
          continue
        fi
        prompts="$(additems "$prompts" "$prefix")"
        prompts="$(additional_prompts "$kind" "$prompts")"
        if test $? -ne 0; then
          continue
        fi
      fi
      current_items="$("$CLIGPT_PLATFORM" messages user "$prompt")"
      if test $? -ne 0; then
        continue
      fi
    fi

    if test "$skip" -eq 0 -a -n "$current_items"; then
      prompts="$(additems "$prompts" "$current_items")"
    fi

    draw_ui
    response="$("$CLIGPT_PLATFORM" chat/completions "$prompts")"
    if ! handle_status "$?"; then
      return 1
    fi
    restore_ui
    local content="$(parsejson "$response" '.content')"
    prompts="$(additem "$prompts" "$response")"
    if test -n "$context"; then
      printf '%s[Assistant]%s %s\n' "$esc_yellow" "$esc_reset" "$content"
    else
      printf '%s\n' "$content"
    fi
    # clear attachments
    CLIGPT_FILE=""

    if test -z "$context"; then
      break
    elif test "$context" != '-'; then
      printf '%s' "$prompts" > "$context"
    fi
  done
}

hook() {
  COMMIT_MSG_FILE="$1"
  COMMIT_SOURCE="$2"

  if test -n "$COMMIT_SOURCE"; then
    exit 0
  fi
  if test -z "$GPT_COMMIT_PROMPT"; then
    GPT_COMMIT_PROMPT="Write a one-line commit message in plain text (not a markdown) not exceeding 79 characters. The following is the last 5 commit messages from the project along with the changes itself, stick to the pattern of the project:"
  fi

  GIT_COMMITS="$(git log -5 --pretty=format:'%s' --no-merges)"
  GIT_CHANGES="$(git diff --staged)"

  if test "$GIT_CHANGES" = ""; then
      printf 'No changes to commit.\n'
      exit 0
  fi

  printf 'Generating commit message...\n'

  GPT_MSG="$(printf '%s\n\n%s\n\n%s' "$GPT_COMMIT_PROMPT" "$GIT_COMMITS" "$GIT_CHANGES" | main)"
  if test $? -ne 0; then
      printf '%s\n' "$GPT_MSG"
      exit $?
  fi
  COMMIT_MSG="$(cat "$COMMIT_MSG_FILE")"

  printf '# %s\n%s' "$GPT_MSG" "$COMMIT_MSG" > "$COMMIT_MSG_FILE"
}

setup_zsh() {
  cat <<'EOF'
gpt_prompt() {
  if [[ "$1" = "#"* ]]; then
    INPUT="${1#"#"}"
    printf "Asking GenAI for command...\r"
EOF
  printf "    print -z \"\$(%s --cmd \"\$INPUT\")\"\n" "$cmd_name"
  cat <<'EOF'
    return
  fi
}

gpt_prompt_handler() {
  if [[ "$1" = "#"* ]]; then
    return
  elif test -n "${functions[gpt_prompt_fallback]}"; then
    gpt_prompt_fallback "$*"
  else
    echo "zsh: command not found: $1"
  fi
}

if test -n "${functions[command_not_found_handler]}"; then
  functions[gpt_prompt_fallback]="${functions[command_not_found_handler]}"
fi
command_not_found_handler() {
  gpt_prompt_handler "$*"
}

preexec_functions+=gpt_prompt
EOF
}

self_test() {
  local test_result=0
  if ! test -n "$(command -v curl)"; then
    echo "ERROR: curl is required" >&2
    test_result=1
  fi
  if ! test -n "$(command -v jq)"; then
    echo "ERROR: jq is required" >&2
    test_result=1
  elif test "$(jq --version | rev | cut -c1-6 | rev)" = "-dirty"; then
    # macOS Sequoia comes with jq, but lack certain functionalities (such as return code)
    echo "ERROR: jq is found to be a dirty version ($(jq --version)) which might not working correctly." >&2
    echo "Try install a more stable version instead." >&2
    test_result=1
  fi
  if ! test -n "$(command -v base64)"; then
    echo "WARN: base64 is missing, file attachment will be disabled" >&2
  fi

  return $test_result
}

case "$cmd_name" in
  prepare-commit-msg)
    hook "$@"
    ;;
  *)
    if ! self_test; then
      exit 1
    fi
    main "$@"
    ;;
esac
