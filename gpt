#!/bin/bash

CLIGPT_PLATFORM_REPO="spywhere/gpt"
CLIGPT_PLATFORM_PATH="platforms"

if test -z "$HOME"; then
  HOME="$(printf "%s" ~)"
fi

tempfile="$(mktemp)"
cmd_name="$(basename "$0")"
debug=0
fancy=0
padding=1
context=""

is_fancy() {
  return $(( 1 - fancy ))
}

esc_reset="" # reset
esc_blue="" # indicate process
esc_green="" # indicate options and information
esc_yellow="" # indicate warnings
esc_red="" # indicate errors

inline_support=0
if test -n "$CLIGPT_FORCE_COLOR" || (test -t 1 && test -n "$TERM" -a -n "$(command -v tput)" && test "$(tput colors)" -ge 8 && test -n "$(command -v tty)"); then
  if test -n "$(command -v wc)"; then
    inline_support=1
  fi
  esc_reset="$(tput sgr0)"
  if test "$(tput colors)" -gt 8; then
    esc_blue="$(tput setaf 12)"
    esc_green="$(tput setaf 10)"
    esc_yellow="$(tput setaf 11)"
    esc_red="$(tput setaf 9)"
  else
    esc_blue="$(tput setaf 4)"
    esc_green="$(tput setaf 2)"
    esc_yellow="$(tput setaf 3)"
    esc_red="$(tput setaf 1)"
  fi

  draw_ui() {
    if ! is_fancy || test -z "$context"; then
      return
    fi
    tput sc
    tput cup "$(( $(tput lines) - 2 - padding ))" 0
    printf '%s\n' "$(repeat -)"
  }

  restore_ui() {
    if ! is_fancy || test -z "$context"; then
      return
    fi
    tput rc
    tput ed
    tput rc >&2
    tput ed >&2
  }
else
  draw_ui() {
    return 0
  }
  restore_ui() {
    return 0
  }
fi

is_interactive() {
  return $(( 1 - inline_support ))
}

bootstrap() {
  if test -z "$CLIGPT_PLATFORM_STORAGE"; then
    if test -f README.md -a -f "./gpt" -a -d "./.git"; then
      # probably in the development mode
      CLIGPT_PLATFORM_STORAGE="./platforms"
    else
      CLIGPT_PLATFORM_STORAGE="$HOME/.gpt"
    fi
  fi

  if test -z "$CLIGPT_CONTEXT_STORAGE"; then
    CLIGPT_CONTEXT_STORAGE="."
  fi
  if test -z "$CLIGPT_TIMEOUT"; then
    CLIGPT_TIMEOUT=30
  fi

  load_platforms
}

fallback_default() {
  if test -n "$1" -a "$1" != "$3"; then
    printf '%s' "$1"
  elif test -n "$2"; then
    printf '%s' "$2"
  else
    printf 'platform specific value'
  fi
}

usage() {
  echo "USAGE"
  echo "  $cmd_name [flags] [--] <prompt>..."
  echo "  cat <filename> | $cmd_name [flags] [--] [prompt]..."
  echo
  echo "PLATFORMS"
  if test "$platforms" = "{}"; then
    echo "  A list of platforms will be downloaded upon first run. Or simply run '$cmd_name --platforms' to start download now"
  else
    first_line='      \(.value.description)\n'
    second_line='        Default API base URL : \(.value.base // "None specified") (can be set through CLIGPT_\(.value.key)_API_BASE)'
    third_line='        Default model        : \(.value.model // "None specified") (can be set through CLIGPT_\(.value.key)_MODEL)'
    parsejson "$platforms" -S "to_entries | map(\"  - \(.key)\n$first_line$second_line\n$third_line\") | join(\"\n\")"
    echo
    echo "  By default, each platform will be tested for a valid setup and get selected. Any platform required a remote call will not be tested and will be selected as a fallback."
  fi

  echo
  echo "ENVIRONMENT VARIABLES"
  echo "  CLIGPT_API_BASE                  Base URL for LLM platform API (see PLATFORMS above for more details)"
  echo "  CLIGPT_API_AUTHORIZATION         Set an Authorization header to the given value"
  echo
  echo "  CLIGPT_PLATFORM                  Platform to use, see the -p, --platform flag below"
  echo "  CLIGPT_MODEL                     ID of the model to use, see the -m, --model flag below"
  echo "  CLIGPT_TEMP                      Sampling temperature, see the -T, --temperature flag below"
  echo "  CLIGPT_TOKEN                     Maximum number of tokens to generate in the completion, see the -t, --max-tokens flag below"
  echo "  CLIGPT_TIMEOUT                   Maximum number of seconds before request timed out, see the --timeout flag below"
  echo "  CLIGPT_FORCE_COLOR               Set to non-empty to force rendering with colors"
  echo "  CLIGPT_CONTEXT_STORAGE           Directory to store/load the context file (currently set to $(fallback_default "$CLIGPT_CONTEXT_STORAGE" "current directory" "."))"
  echo "  CLIGPT_PLATFORM_STORAGE          Directory to store/load the supported platforms (currently set to $CLIGPT_PLATFORM_STORAGE)"
  echo
  echo "FLAGS"
  echo "  -h, --help                       Show this message"
  echo "  -p, --platform=<name>            LLM platform to use (see PLATFORMS above for more details)"
  echo "  -m, --model=<name>               ID of the model to use (default to $(fallback_default "$CLIGPT_MODEL"))"
  echo "  -T, --temperature=<temp>         Sampling temperature, higher is more random (default to $(fallback_default "$CLIGPT_TEMP"))"
  echo "  -t, --max-tokens=<number>        Maximum number of tokens to generate in the completion (default to $(fallback_default "$CLIGPT_TOKEN"))"
  echo "  -c, --context, --context=<file>  Use chat context (default to false), optionally use and store the context in the given file. The prompt from command line will be passed as a system message to the assistant, cannot be used in a pipe"
  echo "  --timeout=<number>               Maximum number of seconds before request timed out (default to "$(fallback_default "$CLIGPT_TIMEOUT")")"
  echo "  --fancy[=<number>]               Use fancy UI with the given minimum padding (default to "$padding")"
  echo "  --platforms                      List all available platforms (will start download supported platforms if no platform found)"
  echo "  --models                         List all available models"
  echo "  --uuid                           A unique ID for verifying the tool"
  echo "  --debug                          Print request and response on to standard error"
  echo "  --debug-dry                      Print request to standard error, but do not make a request"
  echo
  echo "PROMPT HELPER -- cannot used with context"
  echo "  --cmd, --command                 Produce only shell command output"
  echo "  --code                           Produce only one-liner code"
  echo "  --url                            Produce only URL for the given query"
  echo
  echo "CONTEXT LOADER"
  echo "  --fzf                            Fuzzy search for the context file in context storage (see CLIGPT_CONTEXT_STORAGE above) using fzf (fzf is required)"

  if test "$cmd_name" != "prepare-commit-msg"; then
    echo
    echo "ADDITIONAL USAGE"
    echo "  Symlink (or copy) this script as your 'prepare-commit-msg' hook on your git repository to have GPT suggested a commit message"
    echo "    ln -fs $0 /path/to/repo/.git/hooks/prepare-commit-msg"
    echo
    echo "  Add the following line to your .zshrc to enable GPT command lookup using '# <query>'"
    echo "    . <($cmd_name --zsh)"
  fi
}

prompt_prefix() {
  local prompt
  case "$1" in
    copilot)
      prompt='a structured and complete explanations of shell commands. We follow the commands piece-by-piece in bullet-point form, with multiple statements being separate bullets. Sub-commands form sub-bullets. All flags are explained as sub-bullets.'
      ;;
    command)
      prompt='a one-liner posix shell command with no prompt or explanation. Only produce the shell command in plain text with no escape or syntax settings and nothing else, the command will use for execution as-is.'
      ;;
    code)
      prompt='a one-liner code with no prompt or explanation. Only produce the code in plain text with no escape or syntax settings and nothing else, the code will use for execution as-is.'
      ;;
    url)
      prompt='an URL regarding on the topic given. Only produce the URL in plain text with no escape or syntax settings and nothing else, the URL will be open in the browser directly.'
      ;;
  esac

  printf 'Given the user request, only produce %s' "$prompt"
}

copilot_examples() {
  local prompts="$*"
  local result

  local command='find -name "*.ts" | grep -v node_modules'
  prompts="$(additem "$prompts" "$(printf '{"role":"user","content":%s}' "$(tojson "$command")")")"
  # shellcheck disable=SC2016
  result="$(printf -- '--- Command ---\n\n%s\n\n--- Explanation ---\n\n- %s\n  - %s\n- %s\n  - %s' "$command" '`find` is used to list files.' '`-name "*.ts"` stipulates that we search for files ending in `.ts`.' '`| grep` means we pass that list of files to `grep` which filters the list.' '`-v node_modules` means we exclude all files containing node_modules in its path.')"
  prompts="$(additem "$prompts" "$(printf '{"role":"assistant","content":%s}' "$(tojson "$result")")")"

  # shellcheck disable=SC2016
  command="$(printf '%s\n  %s\n  %s\n%s' 'for file in $(find -name "*.py"); do' 'echo "$file";' 'wc -l $file;' 'done')"
  prompts="$(additem "$prompts" "$(printf '{"role":"user","content":%s}' "$(tojson "$command")")")"
  # shellcheck disable=SC2016
  result="$(printf -- '--- Command ---\n\n%s\n\n--- Explanation ---\n\n- %s\n  - %s\n    - %s\n- %s\n  - %s\n  - %s\n    - %s' "$command" 'The for loop iterates over a list of items and executes its body for each, using the loop variable `$file`.' 'The list of items is the output of a sub-call to `find` which is used to list files.' '`-name "*.py"` stipulates that we search for files ending in `.py`.' 'The loop body executes two commands for each file:' '`echo "$file"` will print the name of the current file to the terminal.' '`wc` is used to count the number of lines in the current file.' '`-l` specifies that we only want the line count, not the word or character count.')"
  prompts="$(additem "$prompts" "$(printf '{"role":"assistant","content":%s}' "$(tojson "$result")")")"

  printf '%s' "$prompts"
}

additional_prompts() {
  case "$1" in
    copilot)
      copilot_examples "$2"
      ;;
    *)
      printf '%s' "$2"
  esac
}

handle_gpt_response() {
  local response="$1"
  local errmsg
  errmsg="$(printf '%s' "$response" | jq -er '.error.message')"
  if test "$?" -eq 0; then
    restore_ui
    printf 'ERROR: [%s] %s\n' "$(parsejson "$response" '.error.type')" "$errmsg" >&2
    return 1
  fi
  return 0
}

loader() {
  local pid=$1
  local anim=".  .. ... ..  .   "
  local delay=0.3
  while true; do
    if ! kill -0 "$pid" 2>/dev/null; then
      printf '\r   \r' >&2
      break
    fi

    local char="$(echo "$anim" | cut -c1-3)"
    printf '\r%s' "$char" >&2
    anim="$(echo "$anim" | cut -c4-)$char"
    sleep "$delay"
  done

  wait "$pid"
  return $?
}

run_task() {
  local task="$1"
  if ! is_interactive; then
    "$task"
    return $?
  fi

  "$task" >"$tempfile" &
  loader "$!"
  local code="$?"
  cat "$tempfile"
  return "$code"
}

load_platforms() {
  platforms="{}"
  for platform_path in "$CLIGPT_PLATFORM_STORAGE"/*.sh; do
    local platform_name="$(basename "$platform_path")"
    if test "$platform_name" = '*.sh'; then
      break
    fi

    . "$platform_path"
    local platform_data="$(platform_info)"
    platforms="$(setitem "$platforms" "$(parsejson "$platform_data" '.fn')" "$platform_data")"
  done
}

download_platforms() {
  if test "$platforms" != "{}"; then
    return
  fi

  echo "Fetching platforms..." >&2
  platform_files="$(curl -sSL -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" "https://api.github.com/repos/$CLIGPT_PLATFORM_REPO/contents/$CLIGPT_PLATFORM_PATH" | jq 'map({ (.name|tostring): . }) | add')"
  if test "$?" -ne 0; then
    echo "ERROR: failed to fetch a list of platforms" >&2
    return 1
  fi
  for platform_file in $(parsejson "$platform_files" 'keys[]'); do
    local platform_data="$(parsejson "$platform_files" ".[\"$platform_file\"]")"
    local platform_url="$(parsejson "$platform_data" '.download_url')"

    if ! test -d "$CLIGPT_PLATFORM_STORAGE"; then
      printf "Creating a directory '%s'... " "$CLIGPT_PLATFORM_STORAGE" >&2
      mkdir -p "$CLIGPT_PLATFORM_STORAGE"
      printf 'done\n'
    fi

    printf "Downloading platform '%s' into '%s'... " "$platform_file" "$CLIGPT_PLATFORM_STORAGE/$platform_file" >&2
    curl -sSL "$platform_url" -o "$CLIGPT_PLATFORM_STORAGE/$platform_file" 1>/dev/null 2>&1
    if test "$?" -ne 0; then
      printf 'failed\n' >&2
      echo "ERROR: failed to download platform '$platform_file'" >&2
      return 1
    fi
    printf 'done\n' >&2
  done

  load_platforms

  if test "$platforms" = "{}"; then
    echo "ERROR: no available platform found" >&2
    return 1
  fi
}

validate_platform() {
  if ! download_platforms; then
    return 2
  fi

  local has_test=0
  if test -z "$CLIGPT_PLATFORM"; then
    for platform_name in $(parsejson "$platforms" 'keys[]'); do
      if "$platform_name" test; then
        CLIGPT_PLATFORM="$platform_name"
        has_test=1
        echo "No platform specified, using '$CLIGPT_PLATFORM' instead" >&2
        break
      fi
    done
  fi

  if test -z "$CLIGPT_PLATFORM"; then
    echo "ERROR: no valid platform found" >&2
    return 1
  fi

  local platform_data="$(parsejson "$platforms" ".[\"$CLIGPT_PLATFORM\"].fn // \"\"")"
  if test $? -ne 0 -o -z "$platform_data"; then
    echo "ERROR: platform '$CLIGPT_PLATFORM' is not a valid platform" >&2
    return 1
  fi

  if test "$has_test" -eq 0 && ! "$CLIGPT_PLATFORM" test; then
    echo "ERROR: platform '$CLIGPT_PLATFORM' is not a valid platform (failed the test)" >&2
    return 3
  fi
}

handle_status() {
  local status="$1"
  case "$status" in
    0)
      ;;
    1)
      restore_ui
      echo "ERROR: Request timed out" >&2
      ;;
    2)
      restore_ui
      echo "ERROR: Bad response" >&2
      ;;
    3|4)
      ;;
    *)
      restore_ui
      echo "ERROR: Request failed" >&2
      ;;
  esac
  return "$status"
}

parsejson() {
  local value="$1"
  shift
  printf '%s' "$value" | jq -r "$@"
}

tojson() {
  printf '%s' "$*" | jq -sRr 'tojson'
}

setitem() {
  printf '{"o":%s,"k":%s,"v":%s}' "$1" "$(tojson "$2")" "$3" | jq -rc '.o[.k] = .v | .o'
}

additem() {
  printf '{"o":%s,"i":%s}' "$1" "$2" | jq -rc '.o + [.i]'
}

list_platforms() {
  if ! download_platforms; then
    return 1
  fi

  echo "Available platforms:"
  parsejson "$platforms" 'keys[] | "  - \(.)"'
}

models() {
  echo "Available models:"
  local models="$("$CLIGPT_PLATFORM" models)"
  if ! handle_status "$?"; then
    exit 1
  fi
  parsejson "$models" '.[] | "  - \(.id)\n      by: \(.by)"'
}

validate_context() {
  local context="$1"
  if ! test -f "$context"; then
    echo "ERROR: a given context '$context' is not found" >&2
    return 1
  fi

  local prompts="$(jq -c . "$context" 2>/dev/null)"
  if test $? -ne 0; then
    echo "ERROR: a given context '$context' is not in a correct structure" >&2
    return 1
  fi

  if test -n "$2"; then
    printf '%s' "$prompts"
  fi
}

parse_context() {
  local context="$1"
  if ! validate_context "$context"; then
    return 1
  fi
  local filter=' | "\({"system": "\($blue)[System]\($reset)", "user": "\($green)[User]\($reset)", "assistant": "\($yellow)[Assistant]\($reset)"}[.role] // "[\(.role  / "" | .[:1] |= map(ascii_upcase) | add)]") \(.content)"'
  jq -r ".[]$filter" --arg reset "$esc_reset" --arg blue "$esc_blue" --arg green "$esc_green" --arg yellow "$esc_yellow" "$context"
}

repeat() {
  local str="$1"
  if test -z "$str"; then
    str=" "
  fi
  for i in $(seq "$(tput cols)"); do
    printf '%s' "$str"
  done
}

main() {
  local use_stdin=1
  if tty -s >/dev/null 2>&1; then
    use_stdin=0
  fi
  bootstrap
  local kind=""
  while test "$1" != ""; do
    local param
    param="$(printf "%s" "$1" | sed 's/=.*//g')"
    local value
    value="$(printf "%s" "$1" | sed 's/^[^=]*=//g')"
    local equal_sign
    equal_sign="$(printf "%s" "$1" | sed 's/[^=]//g')"
    case "$param" in
      -h | --help)
        usage
        return
        ;;
      --zsh)
        setup_zsh
        return
        ;;
      --platforms)
        list_platforms
        return
        ;;
      --models)
        models
        return
        ;;
      --uuid)
        echo "4210bbbd-7376-4c55-ac3a-093552be821c"
        return
        ;;
      --fzf)
        if ! test -n "$(command -v fzf)"; then
          echo "ERROR: fzf is required" >&2
          return 1
        fi
        if test -z "$CLIGPT_CONTEXT_STORAGE"; then
          echo "ERROR: GPT_CONTEXT_STORAGE is not yet setup" >&2
          return 1
        elif ! test -d "$CLIGPT_CONTEXT_STORAGE"; then
          echo "ERROR: no context found on \"$CLIGPT_CONTEXT_STORAGE\" (perhaps storage is empty?)" >&2
          return 1
        fi
        shift
        output="$(find "$CLIGPT_CONTEXT_STORAGE" -maxdepth 1 -type f | rev | cut -d'/' -f1 | rev | fzf "--preview=CLIGPT_FORCE_COLOR=1 $0 --parse={}" '--bind=ctrl-/:toggle-preview,ctrl-d:preview-half-page-down,ctrl-u:preview-half-page-up' '--preview-label=Chat History' '--preview-window=down:70%:wrap')"
        if test -z "$output"; then
          return 1
        fi
        context="$(realpath "$CLIGPT_CONTEXT_STORAGE/$output")"
        ;;
      --timeout)
        if test -z "$equal_sign"; then
          echo "ERROR: a number of seconds is required (perhaps missing an equal sign?)" >&2
          return 1
        fi
        CLIGPT_TIMEOUT="$value"
        ;;
      -T | --temperature)
        if test -z "$equal_sign"; then
          echo "ERROR: a temperature is required (perhaps missing an equal sign?)" >&2
          return 1
        fi
        CLIGPT_TEMP="$value"
        ;;
      -t | --max-tokens)
        if test -z "$equal_sign"; then
          echo "ERROR: a number of tokens is required (perhaps missing an equal sign?)" >&2
          return 1
        fi
        CLIGPT_TOKEN="$value"
        ;;
      -p | --platform)
        if test -z "$equal_sign"; then
          echo "ERROR: a platform is required (perhaps missing an equal sign?)" >&2
          return 1
        fi
        CLIGPT_PLATFORM="$value"
        ;;
      -m | --model)
        if test -z "$equal_sign"; then
          echo "ERROR: a model ID is required (perhaps missing an equal sign?)" >&2
          return 1
        fi
        CLIGPT_MODEL="$value"
        ;;
      -c | --context)
        if test -z "$equal_sign"; then
          context='-'
        elif test -f "$CLIGPT_CONTEXT_STORAGE/$value"; then
          context="$(realpath "$CLIGPT_CONTEXT_STORAGE/$value")"
        else
          context="$(realpath "$CLIGPT_CONTEXT_STORAGE")/$value"
        fi
        ;;
      --parse)
        if test -z "$equal_sign"; then
          echo "ERROR: a context is required (perhaps missing an equal sign?)" >&2
          return 1
        else
          parse_context "$value" 2>/dev/null
          if test $? -ne 0; then
            echo "ERROR: a given context '$value' is not in a correct structure" >&2
            return 1
          fi
          return
        fi
        ;;
      --copilot)
        kind="copilot"
        ;;
      --cmd | --command)
        kind="command"
        ;;
      --code)
        kind="code"
        ;;
      --url)
        kind="url"
        ;;
      --fancy)
        fancy=1
        if test -n "$equal_sign"; then
          padding="$value"
        fi
        ;;
      --debug)
        debug=1
        ;;
      --debug-dry)
        debug=2
        ;;
      --)
        shift
        break
        ;;
      -*)
        echo "ERROR: unknown flag \"$1\"" >&2
        return 1
        ;;
      *)
        break
        ;;
    esac

    shift
  done

  if ! validate_platform; then
    return 1
  fi

  local prompt=""
  if test "$use_stdin" -eq 1; then
    if test -n "$context"; then
      echo "ERROR: context cannot be used in the pipe" >&2
      return 1
    fi
    if test -n "$*"; then
      prompt="$(printf '%s:\n%s' "$*" "$(cat -)")"
    else
      prompt="$(cat -)"
    fi
  else
    prompt="$*"
  fi
  if test -z "$context" && test -z "$prompt"; then
    echo "No prompt given" >&2
    echo "Use --help for usage" >&2
    return
  fi

  local prompts="[]"
  if test -n "$context"; then
    if test "$context" != '-'; then
      printf -- "==== Context will be stored in '%s' ====\n" "$context"
    fi
    if test "$context" != '-' && test -f "$context"; then
      prompts="$(validate_context "$context" yes)"
      if test $? -ne 0; then
        return 1
      fi
      parse_context "$context" 2>/dev/null
      if test $? -ne 0; then
        echo "ERROR: a given context '$context' is not in a correct structure" >&2
        return 1
      fi
    elif test -n "$prompt"; then
      local data="$(printf '{"role":"system","content":%s}' "$(tojson "$prompt")")"
      printf '%s[System]%s %s\n' "$esc_blue" "$esc_reset" "$prompt"
      prompts="$(additem "$prompts" "$data")"
    fi
  fi

  while true; do
    if test -n "$context"; then
      draw_ui
      printf '%s[User]%s ' "$esc_green" "$esc_reset"
      if read -r line && test -n "$line"; then
        restore_ui
        if is_fancy; then
          printf '%s[User]%s %s\n' "$esc_green" "$esc_reset" "$line"
        fi
        prompts="$(additem "$prompts" "$(printf '{"role":"user","content":%s}' "$(tojson "$line")")")"
      else
        restore_ui
        break
      fi
    else
      if test -n "$kind"; then
        prompts="$(additem "$prompts" "$(printf '{"role":"system","content":%s}' "$(tojson "$(prompt_prefix "$kind")")")")"
        prompts="$(additional_prompts "$kind" "$prompts")"
      fi
      prompts="$(additem "$prompts" "$(printf '{"role":"user","content":%s}' "$(tojson "$prompt")")")"
    fi

    draw_ui
    response="$("$CLIGPT_PLATFORM" chat/completions "$prompts")"
    if ! handle_status "$?"; then
      return 1
    fi
    restore_ui
    local content="$(parsejson "$response" '.content')"
    prompts="$(additem "$prompts" "$response")"
    if test -n "$context"; then
      printf '%s[Assistant]%s %s\n' "$esc_yellow" "$esc_reset" "$content"
    else
      printf '%s\n' "$content"
    fi

    if test -z "$context"; then
      break
    elif test "$context" != '-'; then
      printf '%s' "$prompts" > "$context"
    fi
  done
}

hook() {
  COMMIT_MSG_FILE="$1"
  COMMIT_SOURCE="$2"

  if test -n "$COMMIT_SOURCE"; then
    exit 0
  fi
  if test -z "$GPT_COMMIT_PROMPT"; then
    GPT_COMMIT_PROMPT="Write a one-line commit message in plain text (not a markdown) not exceeding 79 characters. The following is the last 5 commit messages from the project along with the changes itself, stick to the pattern of the project:"
  fi

  GIT_COMMITS="$(git log -5 --pretty=format:'%s' --no-merges)"
  GIT_CHANGES="$(git diff --staged)"

  if test "$GIT_CHANGES" = ""; then
      printf 'No changes to commit.\n'
      exit 0
  fi

  printf 'Generating commit message...\n'

  GPT_MSG="$(printf '%s\n\n%s\n\n%s' "$GPT_COMMIT_PROMPT" "$GIT_COMMITS" "$GIT_CHANGES" | main)"
  if test $? -ne 0; then
      printf '%s\n' "$GPT_MSG"
      exit $?
  fi
  COMMIT_MSG="$(cat "$COMMIT_MSG_FILE")"

  printf '# %s\n%s' "$GPT_MSG" "$COMMIT_MSG" > "$COMMIT_MSG_FILE"
}

setup_zsh() {
  cat <<'EOF'
gpt_prompt() {
  if [[ "$1" = "#"* ]]; then
    INPUT="${1#"#"}"
    printf "Asking GenAI for command...\r"
EOF
  printf "    print -z \"\$(%s --cmd \"\$INPUT\")\"\n" "$cmd_name"
  cat <<'EOF'
    return
  fi
}

gpt_prompt_handler() {
  if [[ "$1" = "#"* ]]; then
    return
  elif test -n "${functions[gpt_prompt_fallback]}"; then
    gpt_prompt_fallback "$*"
  else
    echo "zsh: command not found: $1"
  fi
}

if test -n "${functions[command_not_found_handler]}"; then
  functions[gpt_prompt_fallback]="${functions[command_not_found_handler]}"
fi
command_not_found_handler() {
  gpt_prompt_handler "$*"
}

preexec_functions+=gpt_prompt
EOF
}

self_test() {
  local test_result=0
  if ! test -n "$(command -v curl)"; then
    echo "ERROR: curl is required" >&2
    test_result=1
  fi
  if ! test -n "$(command -v jq)"; then
    echo "ERROR: jq is required" >&2
    test_result=1
  elif test "$(jq --version | rev | cut -c1-6 | rev)" = "-dirty"; then
    # macOS Sequoia comes with jq, but lack certain functionalities (such as return code)
    echo "ERROR: jq is found to be a dirty version ($(jq --version)) which might not working correctly." >&2
    echo "Try install a more stable version instead." >&2
    test_result=1
  fi

  return $test_result
}

case "$cmd_name" in
  prepare-commit-msg)
    hook "$@"
    ;;
  *)
    if ! self_test; then
      exit 1
    fi
    main "$@"
    ;;
esac
